{"version":3,"file":"chunked-dc.es5.js","sources":["../src/common.ts","../src/chunker.ts","../src/unchunker.ts"],"sourcesContent":["/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n\nexport const RELIABLE_ORDERED_HEADER_LENGTH = 1;\nexport const UNRELIABLE_UNORDERED_HEADER_LENGTH = 9;\n\n/**\n * The mode being used when chunking/unchunking.\n */\nexport const MODE_BITMASK = 6;\nexport const enum Mode {\n    // Important: Changes to the values must correspond to the options field!\n\n    // R R R R R 1 1 E\n    ReliableOrdered = 6,\n    // R R R R R 0 0 E\n    UnreliableUnordered = 0,\n}\n","/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Mode, RELIABLE_ORDERED_HEADER_LENGTH, UNRELIABLE_UNORDERED_HEADER_LENGTH } from './common';\n\n/**\n * A chunker fragments a single message into multiple chunks.\n *\n * For each message to be chunked, a new instance is required.\n */\nabstract class AbstractChunker implements chunkedDc.Chunker {\n    private readonly mode: Mode;\n    private readonly id: number | null;\n    private readonly message: Uint8Array;\n    private readonly headerLength: number;\n    private readonly payloadLength: number;\n    private readonly buffer: ArrayBuffer | null;\n    private offset: number = 0;\n    private serial: number = 0;\n\n    /**\n     * Create a chunker for a specific mode.\n     */\n    protected constructor(\n        mode: Mode, headerLength: number, id: number | null, message: Uint8Array, chunkLength: number,\n        buffer: ArrayBuffer = null,\n    ) {\n        const minChunkSize = headerLength + 1;\n        if (chunkLength < minChunkSize) {\n            throw new Error(`Chunk size must be at least ${minChunkSize}`);\n        }\n        if (buffer !== null && buffer.byteLength < chunkLength) {\n            throw new Error('Buffer too small for chunks');\n        }\n        if (message.byteLength < 1) {\n            throw new Error('Message may not be empty');\n        }\n        if (id != null && (id < 0 || id >= (2 ** 32))) {\n            throw new Error('Message id must be between 0 and 2**32-1');\n        }\n\n        this.mode = mode;\n        this.id = id;\n        this.message = message;\n        this.headerLength = headerLength;\n        this.payloadLength = chunkLength - headerLength;\n        this.buffer = buffer;\n    }\n\n    /**\n     * Whether there are more chunks available.\n     */\n    public get hasNext(): boolean {\n        return this.offset < this.message.byteLength;\n    }\n\n    /**\n     * Iterator implementation. Value is the next Uint8Array chunk.\n     *\n     * Important: When the chunker has been created with an `ArrayBuffer`,\n     *            the underlying buffer of the chunk will be reused in the next\n     *            iteration.\n     */\n    public next(): IteratorResult<Uint8Array> {\n        if (!this.hasNext) {\n            return {\n                done: true,\n                value: null,\n            };\n        }\n\n        // Allocate chunk buffer (if required)\n        const remaining = this.message.byteLength - this.offset;\n        const payloadLength = remaining < this.payloadLength ? remaining : this.payloadLength;\n        const chunkLength = this.headerLength + payloadLength;\n        const endOffset = this.offset + payloadLength;\n        let chunkBuffer: ArrayBuffer;\n        if (this.buffer !== null) {\n            chunkBuffer = this.buffer;\n        } else {\n            chunkBuffer = new ArrayBuffer(chunkLength);\n        }\n\n        // Set header\n        const chunkView = new DataView(chunkBuffer);\n        let options: number = this.mode;\n        if (endOffset === this.message.byteLength) {\n            options |= 1; // tslint:disable-line:no-bitwise\n        }\n        chunkView.setUint8(0, options);\n        switch (this.mode) {\n            case Mode.ReliableOrdered:\n                break;\n            case Mode.UnreliableUnordered:\n                chunkView.setUint32(1, this.id);\n                chunkView.setUint32(5, this.serial++);\n                break;\n        }\n\n        // Set payload\n        const payloadSlice = this.message.subarray(this.offset, endOffset);\n        const chunkArray = new Uint8Array(chunkBuffer, 0, chunkLength);\n        chunkArray.set(payloadSlice, this.headerLength);\n        this.offset = endOffset;\n        return {\n            done: false,\n            value: chunkArray,\n        };\n    }\n\n    /**\n     * Return an iterator over the chunks.\n     */\n    public [Symbol.iterator](): IterableIterator<Uint8Array> {\n        return this;\n    }\n}\n\nexport class ReliableOrderedChunker extends AbstractChunker implements chunkedDc.ReliableOrderedChunker {\n    /**\n     * Create a chunker for reliable & ordered mode.\n     *\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkLength The chunk size *including* header data.\n     * @param buffer A chunk buffer to be used for handing out chunks. Must be\n     *   able to at least contain `chunkLength` bytes. A new buffer will be\n     *   created for every chunk if not supplied.\n     * @throws Error if a chunk would not fit into the specified chunk length,\n     *   if the message is empty, and if the message id is too large.\n     */\n    public constructor(message: Uint8Array, chunkLength: number, buffer?: ArrayBuffer) {\n        super(Mode.ReliableOrdered, RELIABLE_ORDERED_HEADER_LENGTH, null, message, chunkLength, buffer);\n    }\n}\n\nexport class UnreliableUnorderedChunker extends AbstractChunker implements chunkedDc.UnreliableUnorderedChunker {\n    /**\n     * Create a chunker for reliable & ordered mode.\n     *\n     * @param id An identifier for the message. Must be between 0 and 2**32-1.\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkLength The chunk size *including* header data.\n     * @param buffer A chunk buffer to be used for handing out chunks. Must be\n     *   able to at least contain `chunkLength` bytes. A new buffer will be\n     *   created for every chunk if not supplied.\n     * @throws Error if a chunk would not fit into the specified chunk length,\n     *   if the message is empty, and if the message id is too large.\n     */\n    public constructor(id: number, message: Uint8Array, chunkLength: number, buffer?: ArrayBuffer) {\n        super(Mode.UnreliableUnordered, UNRELIABLE_UNORDERED_HEADER_LENGTH, id, message, chunkLength, buffer);\n    }\n}\n","/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Mode, MODE_BITMASK, RELIABLE_ORDERED_HEADER_LENGTH, UNRELIABLE_UNORDERED_HEADER_LENGTH } from './common';\n\n/**\n * Helper class to store chunk information.\n */\nexport class Chunk {\n    public readonly endOfMessage: boolean;\n    public readonly id: number;\n    public readonly serial: number;\n    public readonly payload: Uint8Array;\n\n    /**\n     * Parse the chunk.\n     *\n     * @param chunkArray The chunk's array which will be **referenced**.\n     * @param expectedMode The mode we expect the chunk to use.\n     * @param headerLength The expected header length.\n     * @throws Error if message is smaller than the header length or an unexpected mode has been detected.\n     */\n    public constructor(chunkArray: Uint8Array, expectedMode: Mode, headerLength: number) {\n        if (chunkArray.byteLength < headerLength) {\n            throw new Error('Invalid chunk: Too short');\n        }\n\n        // Read header\n        const chunkView = new DataView(chunkArray.buffer, chunkArray.byteOffset, chunkArray.byteLength);\n        const options = chunkView.getUint8(0);\n        const actualMode = (options & MODE_BITMASK); // tslint:disable-line:no-bitwise\n        if (actualMode !== expectedMode) {\n            throw new Error(`Invalid chunk: Unexpected mode ${actualMode}`);\n        }\n        switch (expectedMode) {\n            case Mode.ReliableOrdered:\n                break;\n            case Mode.UnreliableUnordered:\n                this.id = chunkView.getUint32(1);\n                this.serial = chunkView.getUint32(5);\n                break;\n        }\n        this.endOfMessage = (options & 1) === 1; // tslint:disable-line:no-bitwise\n\n        // Store payload\n        this.payload = chunkArray.subarray(headerLength);\n    }\n}\n\n/**\n * Copies chunks into a contiguous buffer.\n */\nclass ContiguousBufferReassembler {\n    private complete: boolean = false;\n    private buffer: ArrayBuffer | null;\n    private array: Uint8Array | null;\n    private offset: number;\n    private remaining: number;\n\n    /**\n     * Create a reassembler for reliable & ordered mode.\n     *\n     * @param buffer A message buffer to be used for handing out messages.\n     *   If the message grows larger than the underlying buffer, it will be\n     *   replaced. A new buffer will be created when needed if not supplied.\n     */\n    public constructor(buffer: ArrayBuffer | null = null) {\n        this.buffer = buffer;\n        if (this.buffer !== null) {\n            this.array = new Uint8Array(this.buffer);\n            this.offset = 0;\n            this.remaining = this.buffer.byteLength;\n        } else {\n            this.array = null;\n            this.offset = 0;\n            this.remaining = 0;\n        }\n    }\n\n    /**\n     * Return `true` in case nothing has been written to the reassembler, yet.\n     */\n    public get empty(): boolean {\n        return this.offset === 0;\n    }\n\n    /**\n     * Append a chunk to the internal buffer.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @param chunk The chunk to be appended.\n     * @throws Error if the message is already complete.\n     */\n    public add(chunk: Chunk): void {\n        if (this.complete) {\n            throw new Error('Message already complete');\n        }\n        const chunkLength = chunk.payload.byteLength;\n        this.maybeResize(chunkLength);\n        this.complete = chunk.endOfMessage;\n        this.array.set(chunk.payload, this.offset);\n        this.offset += chunkLength;\n        this.remaining -= chunkLength;\n    }\n\n    /**\n     * Append a batch of chunks to the internal buffer.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @param chunks The chunks to be appended.\n     * @param totalByteLength The accumulated byte length of the chunks.\n     * @return the last chunk that has been added.\n     * @throws Error if the message is already complete.\n     */\n    public addBatched(chunks: Chunk[], totalByteLength: number): Chunk {\n        this.maybeResize(totalByteLength);\n        let chunk: Chunk;\n        for (chunk of chunks) {\n            if (this.complete) {\n                throw new Error('Message already complete');\n            }\n            this.complete = chunk.endOfMessage;\n            this.array.set(chunk.payload, this.offset);\n            this.offset += chunk.payload.byteLength;\n        }\n        this.remaining -= totalByteLength;\n        return chunk;\n    }\n\n    /**\n     * Prepare the internal buffer so one or more new chunks can be safely\n     * added.\n     *\n     * Note: We apply a heuristic here to double the buffer's size, so we don't\n     *       need to create new buffers and copy every time. This should be\n     *       faster than merging at the end since we can expect that the local\n     *       machine copies memory faster than it will receive new chunks.\n     *\n     * @param requiredLength The required byte length.\n     */\n    private maybeResize(requiredLength: number): void {\n        // We have no underlying buffer - allocate it directly for the required size\n        if (this.buffer === null) {\n            this.buffer = new ArrayBuffer(requiredLength);\n            this.array = new Uint8Array(this.buffer);\n            return;\n        }\n\n        // Reallocate the underlying buffer if needed\n        if (this.remaining < requiredLength) {\n            const previousArray = this.array;\n            const length = Math.max(previousArray.byteLength * 2, previousArray.byteLength + requiredLength);\n            this.buffer = new ArrayBuffer(length);\n            this.array = new Uint8Array(this.buffer);\n            this.array.set(previousArray);\n            this.remaining = length - this.offset;\n        }\n    }\n\n    /**\n     * Extract the complete message from the internal buffer as a view.\n     *\n     * Important: The returned message's underlying buffer will be reused with\n     *            the next chunk being reassembled.\n     *\n     * @return The completed message.\n     * @throws Error if the message is not yet complete.\n     */\n    public getMessage(): Uint8Array {\n        if (!this.complete) {\n            throw new Error('Message not complete');\n        }\n        const message = this.array.subarray(0, this.offset);\n        this.complete = false;\n        this.offset = 0;\n        this.remaining = this.buffer.byteLength;\n        return message;\n    }\n}\n\n/**\n * Reorders chunks and then copies them into a contiguous buffer.\n */\nclass UnreliableUnorderedReassembler {\n    private readonly contiguousChunks: ContiguousBufferReassembler = new ContiguousBufferReassembler();\n    private queuedChunks: Chunk[] | null = null;\n    private queuedChunksTotalByteLength: number = 0;\n    private _chunkCount: number = 0;\n    private nextOrderedSerial: number = 0;\n    private lastUpdate: number = new Date().getTime();\n    private requiredChunkCount: number | null = null;\n\n    /**\n     * Return the number of added chunks.\n     */\n    public get chunkCount(): number {\n        return this._chunkCount;\n    }\n\n    /**\n     * Return whether the message is complete, meaning that all chunks of the message arrived.\n     */\n    public get complete() {\n        return this.requiredChunkCount !== null && this._chunkCount === this.requiredChunkCount;\n    }\n\n    /**\n     * Add a new chunk.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @throws Error if the message is already complete.\n     */\n    public add(chunk: Chunk): void {\n        // Already complete?\n        if (this.complete) {\n            throw new Error('Message already complete');\n        }\n\n        if (this.queuedChunks === null && chunk.serial === this._chunkCount) {\n            // In order: Can be added to the contiguous chunks\n            this.contiguousChunks.add(chunk);\n            this.nextOrderedSerial = chunk.serial + 1;\n        } else {\n            // Out of order: Needs to be temporarily stored in a queue\n            const ready = this.queueUnorderedChunk(chunk);\n            if (ready) {\n                // Queue is ready to be moved into the contiguous buffer.\n                this.moveQueuedChunks();\n            }\n        }\n\n        // Check if this is the last chunk received\n        if (chunk.endOfMessage) {\n            this.requiredChunkCount = chunk.serial + 1;\n        }\n\n        // Update chunk counter and timestamp\n        ++this._chunkCount;\n        this.lastUpdate = new Date().getTime();\n    }\n\n    /**\n     * Add a new chunk to its intended position in the out-of-order queue.\n     *\n     * Note: We continuously sort the queue by the serial number (ascending).\n     *\n     * @returns whether the queue is ready to be moved into the contiguous buffer.\n     */\n    private queueUnorderedChunk(chunk: Chunk): boolean {\n        // Append chunk\n        this.queuedChunksTotalByteLength += chunk.payload.byteLength;\n        if (this.queuedChunks === null) {\n            this.queuedChunks = [chunk];\n            return false;\n        }\n        this.queuedChunks.push(chunk);\n\n        // Sort chunk queue\n        this.queuedChunks.sort((a: Chunk, b: Chunk) => {\n            if (a.serial < b.serial) {\n                return -1;\n            }\n            if (a.serial > b.serial) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // Check if ready\n        const iterator = this.queuedChunks.values();\n        let previousChunk = iterator.next().value;\n        if (previousChunk.serial !== this.nextOrderedSerial) {\n            return false;\n        }\n        for (const currentChunk of iterator) {\n            if (previousChunk.serial + 1 !== currentChunk.serial) {\n                return false;\n            }\n            previousChunk = currentChunk;\n        }\n        return true;\n    }\n\n    /**\n     * Moves the queued chunks to the contiguous buffer.\n     *\n     * Should be called once the queue contains consecutive chunks and there is\n     * no gap between the contiguous chunk buffer and our queued chunks.\n     */\n    private moveQueuedChunks(): void {\n        const chunk = this.contiguousChunks.addBatched(this.queuedChunks, this.queuedChunksTotalByteLength);\n        // Note: `chunk` is the last chunk in the sequence and has the highest serial number\n        this.nextOrderedSerial = chunk.serial + 1;\n        this.queuedChunks = null;\n    }\n\n    /**\n     * Get the reassembled message.\n     *\n     * @return The completed message.\n     * @throws Error if the message is not yet complete.\n     */\n    public getMessage(): Uint8Array {\n        if (!this.complete) {\n            throw new Error('Message not complete');\n        }\n        return this.contiguousChunks.getMessage();\n    }\n\n    /**\n     * Return whether last chunk is older than the specified number of milliseconds.\n     */\n    public isOlderThan(maxAge: number): boolean {\n        const age = (new Date().getTime() - this.lastUpdate);\n        return age > maxAge;\n    }\n}\n\n/**\n * An unchunker reassembles multiple chunks into a single message.\n */\nabstract class AbstractUnchunker implements chunkedDc.Unchunker {\n    /**\n     * Message listener. Set by the user.\n     *\n     * Important: The passed message's underlying buffer will be reused with\n     *            the next chunk being reassembled.\n     */\n    public onMessage: (message: Uint8Array) => void = null;\n\n    /**\n     * Notify message listener about a complete message.\n     */\n    protected notifyListener(message: Uint8Array) {\n        if (this.onMessage != null) {\n            this.onMessage(message);\n        }\n    }\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing either a 1 byte or 9 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public abstract add(chunkArray: Uint8Array): void;\n}\n\n/**\n * An unchunker for reliable & ordered mode.\n */\nexport class ReliableOrderedUnchunker extends AbstractUnchunker implements chunkedDc.ReliableOrderedUnchunker {\n    private readonly reassembler: ContiguousBufferReassembler;\n\n    /**\n     * Create an unchunker for reliable & ordered mode.\n     *\n     * @param buffer A message buffer to be used for handing out messages.\n     *   If the message grows larger than the underlying buffer, it will be\n     *   replaced. A new buffer will be created when needed if not supplied.\n     */\n    public constructor(buffer?: ArrayBuffer) {\n        super();\n        this.reassembler = new ContiguousBufferReassembler(buffer);\n    }\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing a 1 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public add(chunkArray: Uint8Array): void {\n        // Parse chunk\n        const chunk = new Chunk(chunkArray, Mode.ReliableOrdered, RELIABLE_ORDERED_HEADER_LENGTH);\n\n        // If this is a single chunk that contains the whole message, return it immediately.\n        if (this.reassembler.empty && chunk.endOfMessage) {\n            this.notifyListener(chunk.payload);\n            return;\n        }\n\n        // Add the chunk's payload to the message buffer.\n        this.reassembler.add(chunk);\n\n        // Check if message is complete\n        if (chunk.endOfMessage) {\n            // Hand out the message and reset the buffer\n            this.notifyListener(this.reassembler.getMessage());\n        }\n    }\n}\n\n/**\n * A reassembler optimised for unreliable & unordered mode.\n */\nexport class UnreliableUnorderedUnchunker extends AbstractUnchunker implements chunkedDc.UnreliableUnorderedUnchunker {\n    private reassemblers: Map<number, UnreliableUnorderedReassembler> = new Map();\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing a 9 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public add(chunkArray: Uint8Array): void {\n        // Parse chunk\n        const chunk = new Chunk(chunkArray, Mode.UnreliableUnordered, UNRELIABLE_UNORDERED_HEADER_LENGTH);\n\n        // If this is a single chunk that contains the whole message, return it immediately.\n        if (chunk.endOfMessage && chunk.serial === 0) {\n            this.notifyListener(chunk.payload);\n            return;\n        }\n\n        // Add chunk to reassembler\n        let reassembler: UnreliableUnorderedReassembler = this.reassemblers.get(chunk.id);\n        if (reassembler === undefined) {\n            reassembler = new UnreliableUnorderedReassembler();\n            this.reassemblers.set(chunk.id, reassembler);\n        }\n        reassembler.add(chunk);\n\n        // Check if message is complete\n        if (reassembler.complete) {\n            // Hand out the message and delete the message's reassembler\n            this.notifyListener(reassembler.getMessage());\n            this.reassemblers.delete(chunk.id);\n        }\n    }\n\n    /**\n     * Run garbage collection, remove incomplete messages that haven't been\n     * updated for more than the specified number of milliseconds.\n     *\n     * If you want to make sure that invalid chunks don't fill up memory, call\n     * this method regularly.\n     *\n     * @param maxAge Remove incomplete messages that haven't been updated for\n     *               more than the specified number of milliseconds.\n     */\n    public gc(maxAge: number): number {\n        let removed = 0;\n        for (const [id, reassembler] of this.reassemblers) {\n            if (reassembler.isOlderThan(maxAge)) {\n                removed += reassembler.chunkCount;\n                this.reassemblers.delete(id);\n            }\n        }\n        return removed;\n    }\n}\n"],"names":["RELIABLE_ORDERED_HEADER_LENGTH","UNRELIABLE_UNORDERED_HEADER_LENGTH","MODE_BITMASK","Mode","AbstractChunker","mode","headerLength","id","message","chunkLength","buffer","minChunkSize","Error","byteLength","Math","payloadLength","hasNext","done","value","remaining","offset","endOffset","chunkBuffer","ArrayBuffer","chunkView","DataView","options","setUint8","ReliableOrdered","UnreliableUnordered","setUint32","serial","payloadSlice","subarray","chunkArray","Uint8Array","set","Symbol","iterator","ReliableOrderedChunker","UnreliableUnorderedChunker","Chunk","expectedMode","byteOffset","getUint8","actualMode","getUint32","endOfMessage","payload","ContiguousBufferReassembler","array","chunk","complete","maybeResize","chunks","totalByteLength","requiredLength","previousArray","length","max","UnreliableUnorderedReassembler","Date","getTime","queuedChunks","_chunkCount","contiguousChunks","add","nextOrderedSerial","ready","queueUnorderedChunk","moveQueuedChunks","requiredChunkCount","lastUpdate","queuedChunksTotalByteLength","push","sort","a","b","values","previousChunk","next","currentChunk","addBatched","getMessage","maxAge","age","AbstractUnchunker","onMessage","ReliableOrderedUnchunker","reassembler","empty","notifyListener","UnreliableUnorderedUnchunker","Map","reassemblers","get","undefined","delete","removed","isOlderThan","chunkCount"],"mappings":"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"}